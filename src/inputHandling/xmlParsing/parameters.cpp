// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "parameters.hpp"

// outputParamsType
// 

const outputParamsType::baseName_type& outputParamsType::
baseName () const
{
  return this->baseName_.get ();
}

outputParamsType::baseName_type& outputParamsType::
baseName ()
{
  return this->baseName_.get ();
}

void outputParamsType::
baseName (const baseName_type& x)
{
  this->baseName_.set (x);
}

void outputParamsType::
baseName (::std::unique_ptr< baseName_type > x)
{
  this->baseName_.set (std::move (x));
}

const outputParamsType::writeFrequency_type& outputParamsType::
writeFrequency () const
{
  return this->writeFrequency_.get ();
}

outputParamsType::writeFrequency_type& outputParamsType::
writeFrequency ()
{
  return this->writeFrequency_.get ();
}

void outputParamsType::
writeFrequency (const writeFrequency_type& x)
{
  this->writeFrequency_.set (x);
}


// simulationParamsType
// 

const simulationParamsType::tEnd_type& simulationParamsType::
tEnd () const
{
  return this->tEnd_.get ();
}

simulationParamsType::tEnd_type& simulationParamsType::
tEnd ()
{
  return this->tEnd_.get ();
}

void simulationParamsType::
tEnd (const tEnd_type& x)
{
  this->tEnd_.set (x);
}

const simulationParamsType::deltaT_type& simulationParamsType::
deltaT () const
{
  return this->deltaT_.get ();
}

simulationParamsType::deltaT_type& simulationParamsType::
deltaT ()
{
  return this->deltaT_.get ();
}

void simulationParamsType::
deltaT (const deltaT_type& x)
{
  this->deltaT_.set (x);
}

const simulationParamsType::cutOfRadius_type& simulationParamsType::
cutOfRadius () const
{
  return this->cutOfRadius_.get ();
}

simulationParamsType::cutOfRadius_type& simulationParamsType::
cutOfRadius ()
{
  return this->cutOfRadius_.get ();
}

void simulationParamsType::
cutOfRadius (const cutOfRadius_type& x)
{
  this->cutOfRadius_.set (x);
}

const simulationParamsType::cellSize_type& simulationParamsType::
cellSize () const
{
  return this->cellSize_.get ();
}

simulationParamsType::cellSize_type& simulationParamsType::
cellSize ()
{
  return this->cellSize_.get ();
}

void simulationParamsType::
cellSize (const cellSize_type& x)
{
  this->cellSize_.set (x);
}

const simulationParamsType::Thermostats_type& simulationParamsType::
Thermostats () const
{
  return this->Thermostats_.get ();
}

simulationParamsType::Thermostats_type& simulationParamsType::
Thermostats ()
{
  return this->Thermostats_.get ();
}

void simulationParamsType::
Thermostats (const Thermostats_type& x)
{
  this->Thermostats_.set (x);
}

void simulationParamsType::
Thermostats (::std::unique_ptr< Thermostats_type > x)
{
  this->Thermostats_.set (std::move (x));
}

const simulationParamsType::boundaryConditions_type& simulationParamsType::
boundaryConditions () const
{
  return this->boundaryConditions_.get ();
}

simulationParamsType::boundaryConditions_type& simulationParamsType::
boundaryConditions ()
{
  return this->boundaryConditions_.get ();
}

void simulationParamsType::
boundaryConditions (const boundaryConditions_type& x)
{
  this->boundaryConditions_.set (x);
}

void simulationParamsType::
boundaryConditions (::std::unique_ptr< boundaryConditions_type > x)
{
  this->boundaryConditions_.set (std::move (x));
}

const simulationParamsType::domainDimensions_type& simulationParamsType::
domainDimensions () const
{
  return this->domainDimensions_.get ();
}

simulationParamsType::domainDimensions_type& simulationParamsType::
domainDimensions ()
{
  return this->domainDimensions_.get ();
}

void simulationParamsType::
domainDimensions (const domainDimensions_type& x)
{
  this->domainDimensions_.set (x);
}

void simulationParamsType::
domainDimensions (::std::unique_ptr< domainDimensions_type > x)
{
  this->domainDimensions_.set (std::move (x));
}


// thermoStatsType
// 

const thermoStatsType::initTemp_type& thermoStatsType::
initTemp () const
{
  return this->initTemp_.get ();
}

thermoStatsType::initTemp_type& thermoStatsType::
initTemp ()
{
  return this->initTemp_.get ();
}

void thermoStatsType::
initTemp (const initTemp_type& x)
{
  this->initTemp_.set (x);
}

const thermoStatsType::targetTemp_type& thermoStatsType::
targetTemp () const
{
  return this->targetTemp_.get ();
}

thermoStatsType::targetTemp_type& thermoStatsType::
targetTemp ()
{
  return this->targetTemp_.get ();
}

void thermoStatsType::
targetTemp (const targetTemp_type& x)
{
  this->targetTemp_.set (x);
}

const thermoStatsType::thermoStatFrequency_type& thermoStatsType::
thermoStatFrequency () const
{
  return this->thermoStatFrequency_.get ();
}

thermoStatsType::thermoStatFrequency_type& thermoStatsType::
thermoStatFrequency ()
{
  return this->thermoStatFrequency_.get ();
}

void thermoStatsType::
thermoStatFrequency (const thermoStatFrequency_type& x)
{
  this->thermoStatFrequency_.set (x);
}

const thermoStatsType::maxTempDiff_type& thermoStatsType::
maxTempDiff () const
{
  return this->maxTempDiff_.get ();
}

thermoStatsType::maxTempDiff_type& thermoStatsType::
maxTempDiff ()
{
  return this->maxTempDiff_.get ();
}

void thermoStatsType::
maxTempDiff (const maxTempDiff_type& x)
{
  this->maxTempDiff_.set (x);
}


// vector3DType
// 

const vector3DType::x_type& vector3DType::
x () const
{
  return this->x_.get ();
}

vector3DType::x_type& vector3DType::
x ()
{
  return this->x_.get ();
}

void vector3DType::
x (const x_type& x)
{
  this->x_.set (x);
}

const vector3DType::y_type& vector3DType::
y () const
{
  return this->y_.get ();
}

vector3DType::y_type& vector3DType::
y ()
{
  return this->y_.get ();
}

void vector3DType::
y (const y_type& x)
{
  this->y_.set (x);
}

const vector3DType::z_type& vector3DType::
z () const
{
  return this->z_.get ();
}

vector3DType::z_type& vector3DType::
z ()
{
  return this->z_.get ();
}

void vector3DType::
z (const z_type& x)
{
  this->z_.set (x);
}


// boundaryConditionsType
// 

const boundaryConditionsType::boundaryConditionsPositiveZ_type& boundaryConditionsType::
boundaryConditionsPositiveZ () const
{
  return this->boundaryConditionsPositiveZ_.get ();
}

boundaryConditionsType::boundaryConditionsPositiveZ_type& boundaryConditionsType::
boundaryConditionsPositiveZ ()
{
  return this->boundaryConditionsPositiveZ_.get ();
}

void boundaryConditionsType::
boundaryConditionsPositiveZ (const boundaryConditionsPositiveZ_type& x)
{
  this->boundaryConditionsPositiveZ_.set (x);
}

void boundaryConditionsType::
boundaryConditionsPositiveZ (::std::unique_ptr< boundaryConditionsPositiveZ_type > x)
{
  this->boundaryConditionsPositiveZ_.set (std::move (x));
}

const boundaryConditionsType::boundaryConditionsNegativeZ_type& boundaryConditionsType::
boundaryConditionsNegativeZ () const
{
  return this->boundaryConditionsNegativeZ_.get ();
}

boundaryConditionsType::boundaryConditionsNegativeZ_type& boundaryConditionsType::
boundaryConditionsNegativeZ ()
{
  return this->boundaryConditionsNegativeZ_.get ();
}

void boundaryConditionsType::
boundaryConditionsNegativeZ (const boundaryConditionsNegativeZ_type& x)
{
  this->boundaryConditionsNegativeZ_.set (x);
}

void boundaryConditionsType::
boundaryConditionsNegativeZ (::std::unique_ptr< boundaryConditionsNegativeZ_type > x)
{
  this->boundaryConditionsNegativeZ_.set (std::move (x));
}

const boundaryConditionsType::boundaryConditionsPositiveX_type& boundaryConditionsType::
boundaryConditionsPositiveX () const
{
  return this->boundaryConditionsPositiveX_.get ();
}

boundaryConditionsType::boundaryConditionsPositiveX_type& boundaryConditionsType::
boundaryConditionsPositiveX ()
{
  return this->boundaryConditionsPositiveX_.get ();
}

void boundaryConditionsType::
boundaryConditionsPositiveX (const boundaryConditionsPositiveX_type& x)
{
  this->boundaryConditionsPositiveX_.set (x);
}

void boundaryConditionsType::
boundaryConditionsPositiveX (::std::unique_ptr< boundaryConditionsPositiveX_type > x)
{
  this->boundaryConditionsPositiveX_.set (std::move (x));
}

const boundaryConditionsType::boundaryConditionsNegativeX_type& boundaryConditionsType::
boundaryConditionsNegativeX () const
{
  return this->boundaryConditionsNegativeX_.get ();
}

boundaryConditionsType::boundaryConditionsNegativeX_type& boundaryConditionsType::
boundaryConditionsNegativeX ()
{
  return this->boundaryConditionsNegativeX_.get ();
}

void boundaryConditionsType::
boundaryConditionsNegativeX (const boundaryConditionsNegativeX_type& x)
{
  this->boundaryConditionsNegativeX_.set (x);
}

void boundaryConditionsType::
boundaryConditionsNegativeX (::std::unique_ptr< boundaryConditionsNegativeX_type > x)
{
  this->boundaryConditionsNegativeX_.set (std::move (x));
}

const boundaryConditionsType::boundaryConditionsPositiveY_type& boundaryConditionsType::
boundaryConditionsPositiveY () const
{
  return this->boundaryConditionsPositiveY_.get ();
}

boundaryConditionsType::boundaryConditionsPositiveY_type& boundaryConditionsType::
boundaryConditionsPositiveY ()
{
  return this->boundaryConditionsPositiveY_.get ();
}

void boundaryConditionsType::
boundaryConditionsPositiveY (const boundaryConditionsPositiveY_type& x)
{
  this->boundaryConditionsPositiveY_.set (x);
}

void boundaryConditionsType::
boundaryConditionsPositiveY (::std::unique_ptr< boundaryConditionsPositiveY_type > x)
{
  this->boundaryConditionsPositiveY_.set (std::move (x));
}

const boundaryConditionsType::boundaryConditionsNegativeY_type& boundaryConditionsType::
boundaryConditionsNegativeY () const
{
  return this->boundaryConditionsNegativeY_.get ();
}

boundaryConditionsType::boundaryConditionsNegativeY_type& boundaryConditionsType::
boundaryConditionsNegativeY ()
{
  return this->boundaryConditionsNegativeY_.get ();
}

void boundaryConditionsType::
boundaryConditionsNegativeY (const boundaryConditionsNegativeY_type& x)
{
  this->boundaryConditionsNegativeY_.set (x);
}

void boundaryConditionsType::
boundaryConditionsNegativeY (::std::unique_ptr< boundaryConditionsNegativeY_type > x)
{
  this->boundaryConditionsNegativeY_.set (std::move (x));
}


// cuboidType
// 

const cuboidType::position_type& cuboidType::
position () const
{
  return this->position_.get ();
}

cuboidType::position_type& cuboidType::
position ()
{
  return this->position_.get ();
}

void cuboidType::
position (const position_type& x)
{
  this->position_.set (x);
}

void cuboidType::
position (::std::unique_ptr< position_type > x)
{
  this->position_.set (std::move (x));
}

const cuboidType::velocity_type& cuboidType::
velocity () const
{
  return this->velocity_.get ();
}

cuboidType::velocity_type& cuboidType::
velocity ()
{
  return this->velocity_.get ();
}

void cuboidType::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void cuboidType::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const cuboidType::dimensions_type& cuboidType::
dimensions () const
{
  return this->dimensions_.get ();
}

cuboidType::dimensions_type& cuboidType::
dimensions ()
{
  return this->dimensions_.get ();
}

void cuboidType::
dimensions (const dimensions_type& x)
{
  this->dimensions_.set (x);
}

void cuboidType::
dimensions (::std::unique_ptr< dimensions_type > x)
{
  this->dimensions_.set (std::move (x));
}

const cuboidType::meanVelocity_type& cuboidType::
meanVelocity () const
{
  return this->meanVelocity_.get ();
}

cuboidType::meanVelocity_type& cuboidType::
meanVelocity ()
{
  return this->meanVelocity_.get ();
}

void cuboidType::
meanVelocity (const meanVelocity_type& x)
{
  this->meanVelocity_.set (x);
}

const cuboidType::mass_type& cuboidType::
mass () const
{
  return this->mass_.get ();
}

cuboidType::mass_type& cuboidType::
mass ()
{
  return this->mass_.get ();
}

void cuboidType::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const cuboidType::meshWidth_type& cuboidType::
meshWidth () const
{
  return this->meshWidth_.get ();
}

cuboidType::meshWidth_type& cuboidType::
meshWidth ()
{
  return this->meshWidth_.get ();
}

void cuboidType::
meshWidth (const meshWidth_type& x)
{
  this->meshWidth_.set (x);
}

const cuboidType::sigma_type& cuboidType::
sigma () const
{
  return this->sigma_.get ();
}

cuboidType::sigma_type& cuboidType::
sigma ()
{
  return this->sigma_.get ();
}

void cuboidType::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

const cuboidType::epsilon_type& cuboidType::
epsilon () const
{
  return this->epsilon_.get ();
}

cuboidType::epsilon_type& cuboidType::
epsilon ()
{
  return this->epsilon_.get ();
}

void cuboidType::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}


// sphereType
// 

const sphereType::center_position_type& sphereType::
center_position () const
{
  return this->center_position_.get ();
}

sphereType::center_position_type& sphereType::
center_position ()
{
  return this->center_position_.get ();
}

void sphereType::
center_position (const center_position_type& x)
{
  this->center_position_.set (x);
}

void sphereType::
center_position (::std::unique_ptr< center_position_type > x)
{
  this->center_position_.set (std::move (x));
}

const sphereType::velocity_type& sphereType::
velocity () const
{
  return this->velocity_.get ();
}

sphereType::velocity_type& sphereType::
velocity ()
{
  return this->velocity_.get ();
}

void sphereType::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void sphereType::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const sphereType::meanVelocity_type& sphereType::
meanVelocity () const
{
  return this->meanVelocity_.get ();
}

sphereType::meanVelocity_type& sphereType::
meanVelocity ()
{
  return this->meanVelocity_.get ();
}

void sphereType::
meanVelocity (const meanVelocity_type& x)
{
  this->meanVelocity_.set (x);
}

const sphereType::mass_type& sphereType::
mass () const
{
  return this->mass_.get ();
}

sphereType::mass_type& sphereType::
mass ()
{
  return this->mass_.get ();
}

void sphereType::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const sphereType::radius_type& sphereType::
radius () const
{
  return this->radius_.get ();
}

sphereType::radius_type& sphereType::
radius ()
{
  return this->radius_.get ();
}

void sphereType::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

const sphereType::meshWidth_type& sphereType::
meshWidth () const
{
  return this->meshWidth_.get ();
}

sphereType::meshWidth_type& sphereType::
meshWidth ()
{
  return this->meshWidth_.get ();
}

void sphereType::
meshWidth (const meshWidth_type& x)
{
  this->meshWidth_.set (x);
}

const sphereType::sigma_type& sphereType::
sigma () const
{
  return this->sigma_.get ();
}

sphereType::sigma_type& sphereType::
sigma ()
{
  return this->sigma_.get ();
}

void sphereType::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

const sphereType::epsilon_type& sphereType::
epsilon () const
{
  return this->epsilon_.get ();
}

sphereType::epsilon_type& sphereType::
epsilon ()
{
  return this->epsilon_.get ();
}

void sphereType::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}


// parameters
// 

const parameters::outputParameters_type& parameters::
outputParameters () const
{
  return this->outputParameters_.get ();
}

parameters::outputParameters_type& parameters::
outputParameters ()
{
  return this->outputParameters_.get ();
}

void parameters::
outputParameters (const outputParameters_type& x)
{
  this->outputParameters_.set (x);
}

void parameters::
outputParameters (::std::unique_ptr< outputParameters_type > x)
{
  this->outputParameters_.set (std::move (x));
}

const parameters::simulationParameters_type& parameters::
simulationParameters () const
{
  return this->simulationParameters_.get ();
}

parameters::simulationParameters_type& parameters::
simulationParameters ()
{
  return this->simulationParameters_.get ();
}

void parameters::
simulationParameters (const simulationParameters_type& x)
{
  this->simulationParameters_.set (x);
}

void parameters::
simulationParameters (::std::unique_ptr< simulationParameters_type > x)
{
  this->simulationParameters_.set (std::move (x));
}

const parameters::cuboids_sequence& parameters::
cuboids () const
{
  return this->cuboids_;
}

parameters::cuboids_sequence& parameters::
cuboids ()
{
  return this->cuboids_;
}

void parameters::
cuboids (const cuboids_sequence& s)
{
  this->cuboids_ = s;
}

const parameters::spheres_sequence& parameters::
spheres () const
{
  return this->spheres_;
}

parameters::spheres_sequence& parameters::
spheres ()
{
  return this->spheres_;
}

void parameters::
spheres (const spheres_sequence& s)
{
  this->spheres_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// outputParamsType
//

outputParamsType::
outputParamsType (const baseName_type& baseName,
                  const writeFrequency_type& writeFrequency)
: ::xml_schema::type (),
  baseName_ (baseName, this),
  writeFrequency_ (writeFrequency, this)
{
}

outputParamsType::
outputParamsType (const outputParamsType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  baseName_ (x.baseName_, f, this),
  writeFrequency_ (x.writeFrequency_, f, this)
{
}

outputParamsType::
outputParamsType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  baseName_ (this),
  writeFrequency_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void outputParamsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // baseName
    //
    if (n.name () == "baseName" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< baseName_type > r (
        baseName_traits::create (i, f, this));

      if (!baseName_.present ())
      {
        this->baseName_.set (::std::move (r));
        continue;
      }
    }

    // writeFrequency
    //
    if (n.name () == "writeFrequency" && n.namespace_ ().empty ())
    {
      if (!writeFrequency_.present ())
      {
        this->writeFrequency_.set (writeFrequency_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!baseName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseName",
      "");
  }

  if (!writeFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "writeFrequency",
      "");
  }
}

outputParamsType* outputParamsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class outputParamsType (*this, f, c);
}

outputParamsType& outputParamsType::
operator= (const outputParamsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->baseName_ = x.baseName_;
    this->writeFrequency_ = x.writeFrequency_;
  }

  return *this;
}

outputParamsType::
~outputParamsType ()
{
}

// simulationParamsType
//

simulationParamsType::
simulationParamsType (const tEnd_type& tEnd,
                      const deltaT_type& deltaT,
                      const cutOfRadius_type& cutOfRadius,
                      const cellSize_type& cellSize,
                      const Thermostats_type& Thermostats,
                      const boundaryConditions_type& boundaryConditions,
                      const domainDimensions_type& domainDimensions)
: ::xml_schema::type (),
  tEnd_ (tEnd, this),
  deltaT_ (deltaT, this),
  cutOfRadius_ (cutOfRadius, this),
  cellSize_ (cellSize, this),
  Thermostats_ (Thermostats, this),
  boundaryConditions_ (boundaryConditions, this),
  domainDimensions_ (domainDimensions, this)
{
}

simulationParamsType::
simulationParamsType (const tEnd_type& tEnd,
                      const deltaT_type& deltaT,
                      const cutOfRadius_type& cutOfRadius,
                      const cellSize_type& cellSize,
                      ::std::unique_ptr< Thermostats_type > Thermostats,
                      ::std::unique_ptr< boundaryConditions_type > boundaryConditions,
                      ::std::unique_ptr< domainDimensions_type > domainDimensions)
: ::xml_schema::type (),
  tEnd_ (tEnd, this),
  deltaT_ (deltaT, this),
  cutOfRadius_ (cutOfRadius, this),
  cellSize_ (cellSize, this),
  Thermostats_ (std::move (Thermostats), this),
  boundaryConditions_ (std::move (boundaryConditions), this),
  domainDimensions_ (std::move (domainDimensions), this)
{
}

simulationParamsType::
simulationParamsType (const simulationParamsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  tEnd_ (x.tEnd_, f, this),
  deltaT_ (x.deltaT_, f, this),
  cutOfRadius_ (x.cutOfRadius_, f, this),
  cellSize_ (x.cellSize_, f, this),
  Thermostats_ (x.Thermostats_, f, this),
  boundaryConditions_ (x.boundaryConditions_, f, this),
  domainDimensions_ (x.domainDimensions_, f, this)
{
}

simulationParamsType::
simulationParamsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  tEnd_ (this),
  deltaT_ (this),
  cutOfRadius_ (this),
  cellSize_ (this),
  Thermostats_ (this),
  boundaryConditions_ (this),
  domainDimensions_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulationParamsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // tEnd
    //
    if (n.name () == "tEnd" && n.namespace_ ().empty ())
    {
      if (!tEnd_.present ())
      {
        this->tEnd_.set (tEnd_traits::create (i, f, this));
        continue;
      }
    }

    // deltaT
    //
    if (n.name () == "deltaT" && n.namespace_ ().empty ())
    {
      if (!deltaT_.present ())
      {
        this->deltaT_.set (deltaT_traits::create (i, f, this));
        continue;
      }
    }

    // cutOfRadius
    //
    if (n.name () == "cutOfRadius" && n.namespace_ ().empty ())
    {
      if (!cutOfRadius_.present ())
      {
        this->cutOfRadius_.set (cutOfRadius_traits::create (i, f, this));
        continue;
      }
    }

    // cellSize
    //
    if (n.name () == "cellSize" && n.namespace_ ().empty ())
    {
      if (!cellSize_.present ())
      {
        this->cellSize_.set (cellSize_traits::create (i, f, this));
        continue;
      }
    }

    // Thermostats
    //
    if (n.name () == "Thermostats" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Thermostats_type > r (
        Thermostats_traits::create (i, f, this));

      if (!Thermostats_.present ())
      {
        this->Thermostats_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditions
    //
    if (n.name () == "boundaryConditions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditions_type > r (
        boundaryConditions_traits::create (i, f, this));

      if (!boundaryConditions_.present ())
      {
        this->boundaryConditions_.set (::std::move (r));
        continue;
      }
    }

    // domainDimensions
    //
    if (n.name () == "domainDimensions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< domainDimensions_type > r (
        domainDimensions_traits::create (i, f, this));

      if (!domainDimensions_.present ())
      {
        this->domainDimensions_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!tEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tEnd",
      "");
  }

  if (!deltaT_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "deltaT",
      "");
  }

  if (!cutOfRadius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cutOfRadius",
      "");
  }

  if (!cellSize_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cellSize",
      "");
  }

  if (!Thermostats_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Thermostats",
      "");
  }

  if (!boundaryConditions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditions",
      "");
  }

  if (!domainDimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domainDimensions",
      "");
  }
}

simulationParamsType* simulationParamsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulationParamsType (*this, f, c);
}

simulationParamsType& simulationParamsType::
operator= (const simulationParamsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->tEnd_ = x.tEnd_;
    this->deltaT_ = x.deltaT_;
    this->cutOfRadius_ = x.cutOfRadius_;
    this->cellSize_ = x.cellSize_;
    this->Thermostats_ = x.Thermostats_;
    this->boundaryConditions_ = x.boundaryConditions_;
    this->domainDimensions_ = x.domainDimensions_;
  }

  return *this;
}

simulationParamsType::
~simulationParamsType ()
{
}

// thermoStatsType
//

thermoStatsType::
thermoStatsType (const initTemp_type& initTemp,
                 const targetTemp_type& targetTemp,
                 const thermoStatFrequency_type& thermoStatFrequency,
                 const maxTempDiff_type& maxTempDiff)
: ::xml_schema::type (),
  initTemp_ (initTemp, this),
  targetTemp_ (targetTemp, this),
  thermoStatFrequency_ (thermoStatFrequency, this),
  maxTempDiff_ (maxTempDiff, this)
{
}

thermoStatsType::
thermoStatsType (const thermoStatsType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  initTemp_ (x.initTemp_, f, this),
  targetTemp_ (x.targetTemp_, f, this),
  thermoStatFrequency_ (x.thermoStatFrequency_, f, this),
  maxTempDiff_ (x.maxTempDiff_, f, this)
{
}

thermoStatsType::
thermoStatsType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  initTemp_ (this),
  targetTemp_ (this),
  thermoStatFrequency_ (this),
  maxTempDiff_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void thermoStatsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // initTemp
    //
    if (n.name () == "initTemp" && n.namespace_ ().empty ())
    {
      if (!initTemp_.present ())
      {
        this->initTemp_.set (initTemp_traits::create (i, f, this));
        continue;
      }
    }

    // targetTemp
    //
    if (n.name () == "targetTemp" && n.namespace_ ().empty ())
    {
      if (!targetTemp_.present ())
      {
        this->targetTemp_.set (targetTemp_traits::create (i, f, this));
        continue;
      }
    }

    // thermoStatFrequency
    //
    if (n.name () == "thermoStatFrequency" && n.namespace_ ().empty ())
    {
      if (!thermoStatFrequency_.present ())
      {
        this->thermoStatFrequency_.set (thermoStatFrequency_traits::create (i, f, this));
        continue;
      }
    }

    // maxTempDiff
    //
    if (n.name () == "maxTempDiff" && n.namespace_ ().empty ())
    {
      if (!maxTempDiff_.present ())
      {
        this->maxTempDiff_.set (maxTempDiff_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!initTemp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initTemp",
      "");
  }

  if (!targetTemp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "targetTemp",
      "");
  }

  if (!thermoStatFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "thermoStatFrequency",
      "");
  }

  if (!maxTempDiff_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "maxTempDiff",
      "");
  }
}

thermoStatsType* thermoStatsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class thermoStatsType (*this, f, c);
}

thermoStatsType& thermoStatsType::
operator= (const thermoStatsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->initTemp_ = x.initTemp_;
    this->targetTemp_ = x.targetTemp_;
    this->thermoStatFrequency_ = x.thermoStatFrequency_;
    this->maxTempDiff_ = x.maxTempDiff_;
  }

  return *this;
}

thermoStatsType::
~thermoStatsType ()
{
}

// vector3DType
//

vector3DType::
vector3DType (const x_type& x,
              const y_type& y,
              const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

vector3DType::
vector3DType (const vector3DType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

vector3DType::
vector3DType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void vector3DType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

vector3DType* vector3DType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class vector3DType (*this, f, c);
}

vector3DType& vector3DType::
operator= (const vector3DType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

vector3DType::
~vector3DType ()
{
}

// boundaryConditionsType
//

boundaryConditionsType::
boundaryConditionsType (const boundaryConditionsPositiveZ_type& boundaryConditionsPositiveZ,
                        const boundaryConditionsNegativeZ_type& boundaryConditionsNegativeZ,
                        const boundaryConditionsPositiveX_type& boundaryConditionsPositiveX,
                        const boundaryConditionsNegativeX_type& boundaryConditionsNegativeX,
                        const boundaryConditionsPositiveY_type& boundaryConditionsPositiveY,
                        const boundaryConditionsNegativeY_type& boundaryConditionsNegativeY)
: ::xml_schema::type (),
  boundaryConditionsPositiveZ_ (boundaryConditionsPositiveZ, this),
  boundaryConditionsNegativeZ_ (boundaryConditionsNegativeZ, this),
  boundaryConditionsPositiveX_ (boundaryConditionsPositiveX, this),
  boundaryConditionsNegativeX_ (boundaryConditionsNegativeX, this),
  boundaryConditionsPositiveY_ (boundaryConditionsPositiveY, this),
  boundaryConditionsNegativeY_ (boundaryConditionsNegativeY, this)
{
}

boundaryConditionsType::
boundaryConditionsType (const boundaryConditionsType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  boundaryConditionsPositiveZ_ (x.boundaryConditionsPositiveZ_, f, this),
  boundaryConditionsNegativeZ_ (x.boundaryConditionsNegativeZ_, f, this),
  boundaryConditionsPositiveX_ (x.boundaryConditionsPositiveX_, f, this),
  boundaryConditionsNegativeX_ (x.boundaryConditionsNegativeX_, f, this),
  boundaryConditionsPositiveY_ (x.boundaryConditionsPositiveY_, f, this),
  boundaryConditionsNegativeY_ (x.boundaryConditionsNegativeY_, f, this)
{
}

boundaryConditionsType::
boundaryConditionsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  boundaryConditionsPositiveZ_ (this),
  boundaryConditionsNegativeZ_ (this),
  boundaryConditionsPositiveX_ (this),
  boundaryConditionsNegativeX_ (this),
  boundaryConditionsPositiveY_ (this),
  boundaryConditionsNegativeY_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boundaryConditionsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // boundaryConditionsPositiveZ
    //
    if (n.name () == "boundaryConditionsPositiveZ" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditionsPositiveZ_type > r (
        boundaryConditionsPositiveZ_traits::create (i, f, this));

      if (!boundaryConditionsPositiveZ_.present ())
      {
        this->boundaryConditionsPositiveZ_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditionsNegativeZ
    //
    if (n.name () == "boundaryConditionsNegativeZ" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditionsNegativeZ_type > r (
        boundaryConditionsNegativeZ_traits::create (i, f, this));

      if (!boundaryConditionsNegativeZ_.present ())
      {
        this->boundaryConditionsNegativeZ_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditionsPositiveX
    //
    if (n.name () == "boundaryConditionsPositiveX" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditionsPositiveX_type > r (
        boundaryConditionsPositiveX_traits::create (i, f, this));

      if (!boundaryConditionsPositiveX_.present ())
      {
        this->boundaryConditionsPositiveX_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditionsNegativeX
    //
    if (n.name () == "boundaryConditionsNegativeX" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditionsNegativeX_type > r (
        boundaryConditionsNegativeX_traits::create (i, f, this));

      if (!boundaryConditionsNegativeX_.present ())
      {
        this->boundaryConditionsNegativeX_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditionsPositiveY
    //
    if (n.name () == "boundaryConditionsPositiveY" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditionsPositiveY_type > r (
        boundaryConditionsPositiveY_traits::create (i, f, this));

      if (!boundaryConditionsPositiveY_.present ())
      {
        this->boundaryConditionsPositiveY_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditionsNegativeY
    //
    if (n.name () == "boundaryConditionsNegativeY" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditionsNegativeY_type > r (
        boundaryConditionsNegativeY_traits::create (i, f, this));

      if (!boundaryConditionsNegativeY_.present ())
      {
        this->boundaryConditionsNegativeY_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!boundaryConditionsPositiveZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditionsPositiveZ",
      "");
  }

  if (!boundaryConditionsNegativeZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditionsNegativeZ",
      "");
  }

  if (!boundaryConditionsPositiveX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditionsPositiveX",
      "");
  }

  if (!boundaryConditionsNegativeX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditionsNegativeX",
      "");
  }

  if (!boundaryConditionsPositiveY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditionsPositiveY",
      "");
  }

  if (!boundaryConditionsNegativeY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditionsNegativeY",
      "");
  }
}

boundaryConditionsType* boundaryConditionsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundaryConditionsType (*this, f, c);
}

boundaryConditionsType& boundaryConditionsType::
operator= (const boundaryConditionsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->boundaryConditionsPositiveZ_ = x.boundaryConditionsPositiveZ_;
    this->boundaryConditionsNegativeZ_ = x.boundaryConditionsNegativeZ_;
    this->boundaryConditionsPositiveX_ = x.boundaryConditionsPositiveX_;
    this->boundaryConditionsNegativeX_ = x.boundaryConditionsNegativeX_;
    this->boundaryConditionsPositiveY_ = x.boundaryConditionsPositiveY_;
    this->boundaryConditionsNegativeY_ = x.boundaryConditionsNegativeY_;
  }

  return *this;
}

boundaryConditionsType::
~boundaryConditionsType ()
{
}

// cuboidType
//

cuboidType::
cuboidType (const position_type& position,
            const velocity_type& velocity,
            const dimensions_type& dimensions,
            const meanVelocity_type& meanVelocity,
            const mass_type& mass,
            const meshWidth_type& meshWidth,
            const sigma_type& sigma,
            const epsilon_type& epsilon)
: ::xml_schema::type (),
  position_ (position, this),
  velocity_ (velocity, this),
  dimensions_ (dimensions, this),
  meanVelocity_ (meanVelocity, this),
  mass_ (mass, this),
  meshWidth_ (meshWidth, this),
  sigma_ (sigma, this),
  epsilon_ (epsilon, this)
{
}

cuboidType::
cuboidType (::std::unique_ptr< position_type > position,
            ::std::unique_ptr< velocity_type > velocity,
            ::std::unique_ptr< dimensions_type > dimensions,
            const meanVelocity_type& meanVelocity,
            const mass_type& mass,
            const meshWidth_type& meshWidth,
            const sigma_type& sigma,
            const epsilon_type& epsilon)
: ::xml_schema::type (),
  position_ (std::move (position), this),
  velocity_ (std::move (velocity), this),
  dimensions_ (std::move (dimensions), this),
  meanVelocity_ (meanVelocity, this),
  mass_ (mass, this),
  meshWidth_ (meshWidth, this),
  sigma_ (sigma, this),
  epsilon_ (epsilon, this)
{
}

cuboidType::
cuboidType (const cuboidType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  position_ (x.position_, f, this),
  velocity_ (x.velocity_, f, this),
  dimensions_ (x.dimensions_, f, this),
  meanVelocity_ (x.meanVelocity_, f, this),
  mass_ (x.mass_, f, this),
  meshWidth_ (x.meshWidth_, f, this),
  sigma_ (x.sigma_, f, this),
  epsilon_ (x.epsilon_, f, this)
{
}

cuboidType::
cuboidType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  position_ (this),
  velocity_ (this),
  dimensions_ (this),
  meanVelocity_ (this),
  mass_ (this),
  meshWidth_ (this),
  sigma_ (this),
  epsilon_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboidType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // position
    //
    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< position_type > r (
        position_traits::create (i, f, this));

      if (!position_.present ())
      {
        this->position_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // dimensions
    //
    if (n.name () == "dimensions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dimensions_type > r (
        dimensions_traits::create (i, f, this));

      if (!dimensions_.present ())
      {
        this->dimensions_.set (::std::move (r));
        continue;
      }
    }

    // meanVelocity
    //
    if (n.name () == "meanVelocity" && n.namespace_ ().empty ())
    {
      if (!meanVelocity_.present ())
      {
        this->meanVelocity_.set (meanVelocity_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // meshWidth
    //
    if (n.name () == "meshWidth" && n.namespace_ ().empty ())
    {
      if (!meshWidth_.present ())
      {
        this->meshWidth_.set (meshWidth_traits::create (i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      if (!sigma_.present ())
      {
        this->sigma_.set (sigma_traits::create (i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!epsilon_.present ())
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "position",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!dimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimensions",
      "");
  }

  if (!meanVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "meanVelocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!meshWidth_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "meshWidth",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sigma",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }
}

cuboidType* cuboidType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboidType (*this, f, c);
}

cuboidType& cuboidType::
operator= (const cuboidType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->position_ = x.position_;
    this->velocity_ = x.velocity_;
    this->dimensions_ = x.dimensions_;
    this->meanVelocity_ = x.meanVelocity_;
    this->mass_ = x.mass_;
    this->meshWidth_ = x.meshWidth_;
    this->sigma_ = x.sigma_;
    this->epsilon_ = x.epsilon_;
  }

  return *this;
}

cuboidType::
~cuboidType ()
{
}

// sphereType
//

sphereType::
sphereType (const center_position_type& center_position,
            const velocity_type& velocity,
            const meanVelocity_type& meanVelocity,
            const mass_type& mass,
            const radius_type& radius,
            const meshWidth_type& meshWidth,
            const sigma_type& sigma,
            const epsilon_type& epsilon)
: ::xml_schema::type (),
  center_position_ (center_position, this),
  velocity_ (velocity, this),
  meanVelocity_ (meanVelocity, this),
  mass_ (mass, this),
  radius_ (radius, this),
  meshWidth_ (meshWidth, this),
  sigma_ (sigma, this),
  epsilon_ (epsilon, this)
{
}

sphereType::
sphereType (::std::unique_ptr< center_position_type > center_position,
            ::std::unique_ptr< velocity_type > velocity,
            const meanVelocity_type& meanVelocity,
            const mass_type& mass,
            const radius_type& radius,
            const meshWidth_type& meshWidth,
            const sigma_type& sigma,
            const epsilon_type& epsilon)
: ::xml_schema::type (),
  center_position_ (std::move (center_position), this),
  velocity_ (std::move (velocity), this),
  meanVelocity_ (meanVelocity, this),
  mass_ (mass, this),
  radius_ (radius, this),
  meshWidth_ (meshWidth, this),
  sigma_ (sigma, this),
  epsilon_ (epsilon, this)
{
}

sphereType::
sphereType (const sphereType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  center_position_ (x.center_position_, f, this),
  velocity_ (x.velocity_, f, this),
  meanVelocity_ (x.meanVelocity_, f, this),
  mass_ (x.mass_, f, this),
  radius_ (x.radius_, f, this),
  meshWidth_ (x.meshWidth_, f, this),
  sigma_ (x.sigma_, f, this),
  epsilon_ (x.epsilon_, f, this)
{
}

sphereType::
sphereType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  center_position_ (this),
  velocity_ (this),
  meanVelocity_ (this),
  mass_ (this),
  radius_ (this),
  meshWidth_ (this),
  sigma_ (this),
  epsilon_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void sphereType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // center_position
    //
    if (n.name () == "center_position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< center_position_type > r (
        center_position_traits::create (i, f, this));

      if (!center_position_.present ())
      {
        this->center_position_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // meanVelocity
    //
    if (n.name () == "meanVelocity" && n.namespace_ ().empty ())
    {
      if (!meanVelocity_.present ())
      {
        this->meanVelocity_.set (meanVelocity_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    // meshWidth
    //
    if (n.name () == "meshWidth" && n.namespace_ ().empty ())
    {
      if (!meshWidth_.present ())
      {
        this->meshWidth_.set (meshWidth_traits::create (i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      if (!sigma_.present ())
      {
        this->sigma_.set (sigma_traits::create (i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!epsilon_.present ())
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!center_position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "center_position",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!meanVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "meanVelocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!meshWidth_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "meshWidth",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sigma",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }
}

sphereType* sphereType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphereType (*this, f, c);
}

sphereType& sphereType::
operator= (const sphereType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->center_position_ = x.center_position_;
    this->velocity_ = x.velocity_;
    this->meanVelocity_ = x.meanVelocity_;
    this->mass_ = x.mass_;
    this->radius_ = x.radius_;
    this->meshWidth_ = x.meshWidth_;
    this->sigma_ = x.sigma_;
    this->epsilon_ = x.epsilon_;
  }

  return *this;
}

sphereType::
~sphereType ()
{
}

// parameters
//

parameters::
parameters (const outputParameters_type& outputParameters,
            const simulationParameters_type& simulationParameters)
: ::xml_schema::type (),
  outputParameters_ (outputParameters, this),
  simulationParameters_ (simulationParameters, this),
  cuboids_ (this),
  spheres_ (this)
{
}

parameters::
parameters (::std::unique_ptr< outputParameters_type > outputParameters,
            ::std::unique_ptr< simulationParameters_type > simulationParameters)
: ::xml_schema::type (),
  outputParameters_ (std::move (outputParameters), this),
  simulationParameters_ (std::move (simulationParameters), this),
  cuboids_ (this),
  spheres_ (this)
{
}

parameters::
parameters (const parameters& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  outputParameters_ (x.outputParameters_, f, this),
  simulationParameters_ (x.simulationParameters_, f, this),
  cuboids_ (x.cuboids_, f, this),
  spheres_ (x.spheres_, f, this)
{
}

parameters::
parameters (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  outputParameters_ (this),
  simulationParameters_ (this),
  cuboids_ (this),
  spheres_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void parameters::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // outputParameters
    //
    if (n.name () == "outputParameters" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< outputParameters_type > r (
        outputParameters_traits::create (i, f, this));

      if (!outputParameters_.present ())
      {
        this->outputParameters_.set (::std::move (r));
        continue;
      }
    }

    // simulationParameters
    //
    if (n.name () == "simulationParameters" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< simulationParameters_type > r (
        simulationParameters_traits::create (i, f, this));

      if (!simulationParameters_.present ())
      {
        this->simulationParameters_.set (::std::move (r));
        continue;
      }
    }

    // cuboids
    //
    if (n.name () == "cuboids" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboids_type > r (
        cuboids_traits::create (i, f, this));

      this->cuboids_.push_back (::std::move (r));
      continue;
    }

    // spheres
    //
    if (n.name () == "spheres" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< spheres_type > r (
        spheres_traits::create (i, f, this));

      this->spheres_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!outputParameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "outputParameters",
      "");
  }

  if (!simulationParameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "simulationParameters",
      "");
  }
}

parameters* parameters::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class parameters (*this, f, c);
}

parameters& parameters::
operator= (const parameters& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->outputParameters_ = x.outputParameters_;
    this->simulationParameters_ = x.simulationParameters_;
    this->cuboids_ = x.cuboids_;
    this->spheres_ = x.spheres_;
  }

  return *this;
}

parameters::
~parameters ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::parameters >
parameters_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::parameters > (
    ::parameters_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::parameters >
parameters_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::parameters > (
    ::parameters_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::parameters >
parameters_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::parameters > (
    ::parameters_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::parameters >
parameters_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::parameters_ (isrc, f, p);
}

::std::unique_ptr< ::parameters >
parameters_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::parameters_ (isrc, h, f, p);
}

::std::unique_ptr< ::parameters >
parameters_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::parameters_ (isrc, h, f, p);
}

::std::unique_ptr< ::parameters >
parameters_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::parameters_ (isrc, f, p);
}

::std::unique_ptr< ::parameters >
parameters_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::parameters_ (isrc, h, f, p);
}

::std::unique_ptr< ::parameters >
parameters_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::parameters_ (isrc, h, f, p);
}

::std::unique_ptr< ::parameters >
parameters_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::parameters > (
    ::parameters_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::parameters >
parameters_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::parameters > (
    ::parameters_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::parameters >
parameters_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::parameters > (
    ::parameters_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::parameters >
parameters_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::parameters > (
      ::parameters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "parameters" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::parameters > r (
      ::xsd::cxx::tree::traits< ::parameters, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "parameters",
    "");
}

::std::unique_ptr< ::parameters >
parameters_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "parameters" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::parameters > r (
      ::xsd::cxx::tree::traits< ::parameters, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "parameters",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

